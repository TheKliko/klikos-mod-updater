import os
import re
import shutil
import time
from PIL import Image


def is_same_icon(icon1: Image.Image, icon2: Image.Image) -> bool:
    if icon1.mode != icon2.mode or icon1.size != icon2.size:
        return False
    
    data1 = icon1.load()
    data2 = icon2.load()

    for x in range(icon1.width):
        for y in range(icon1.height):
            if data1[x, y] != data2[x, y]:
                if icon1.mode == 'RGBA':
                    if data1[x,y][3] == 0 and data2[x,y][3] == 0:
                        continue
                return False
    
    return True


def get_icon_map(paths: list) -> dict:
    for path in paths:
        if not os.path.exists(path):
            continue
        
        with open(path, 'r') as file:
            data = file.read()
            file.close()

        icon_map = parse_lua_file(data)
        break

    else:  # Both paths were invalid
        raise Exception('[icons.get_icon_map()]: Failed to find `ImageSetData.lua`')
    
    return icon_map


# Generated by ChatGPT (regex looks like magic to me),
# then slightly modified to fix some issues
def parse_lua_file(file_content) -> dict:
    data: dict = {'1x': {}, '2x': {}, '3x': {}}

    # Define a regex pattern to match the asset blocks for each size
    pattern = r"function make_assets_(\dx)\(\).*?(\{.*?\}) end"
    matches = re.findall(pattern, file_content, re.DOTALL)
    
    # Iterate over the matches to extract the data
    for size, block in matches:
        # Find all the icon definitions within the block
        icon_pattern = r"\['([^']+)'\] = \{ ImageRectOffset = Vector2\.new\((\d+), (\d+)\), ImageRectSize = Vector2\.new\((\d+), (\d+)\), ImageSet = '([^']+)' \}"

        icons = re.findall(icon_pattern, block)
        
        for icon in icons:
            icon_name, x, y, w, h, img_set = icon
            data[size][icon_name] = {
                'set': img_set,
                'x': int(x),
                'y': int(y),
                'w': int(w),
                'h': int(h)
            }
    return data


def get_modded_icons(data: dict, paths_1: list, paths_2: list) -> dict:
    for path in paths_1:
        if os.path.isdir(path):
            atlas_1_path = path

    for path in paths_2:
        if os.path.isdir(path):
            atlas_2_path = path

    if atlas_1_path == None or atlas_2_path == None:
        if atlas_1_path == None and atlas_2_path != None:
            raise Exception('atlas_1_path does not exist!')
        if atlas_1_path != None and atlas_2_path == None:
            raise Exception('atlas_2_path does not exist!')
        if atlas_1_path == None and atlas_2_path == None:
            raise Exception('atlas_1_path & atlas_2_path do not exist!')

    modded_icons: dict = {
        '1x': [],
        '2x': [],
        '3x': []
    }

    for size, icons in data.items():
        for name in list(icons.keys()):
            imageset: str = data[size][name]['set']
            x: int = data[size][name]['x']
            y: int = data[size][name]['y']
            w: int = data[size][name]['w']
            h: int = data[size][name]['h']

            path_1: str = os.path.join(atlas_1_path, f'{imageset}.png')
            path_2: str = os.path.join(atlas_2_path, f'{imageset}.png')

            if not os.path.isfile(path_1):
                continue

            if not os.path.isfile(path_2):
                raise Exception(f'Could not find {os.path.basename(path_2)}')

            icon_1: Image.Image = Image.open(path_1).crop((x,y,x+w,y+h))
            icon_2: Image.Image = Image.open(path_2).crop((x,y,x+w,y+h))

            if not is_same_icon(icon_1, icon_2):
                # print(f'Modded icon detected: {size}/{name}')
                modded_icons[size].append(name)

                # preview_image: Image.Image = Image.new('RGBA', (w*2, h))
                # preview_image.paste(icon_1, (0,0))
                # preview_image.paste(icon_2, (w, 0))
                # print(f'icon preview: {name}')
                # preview(preview_image)

    return modded_icons


def generate_imagesets(data_modded: dict, data_new: dict, modded_icons: dict, modded_icon_paths: list, unmodded_icon_paths: list, savepath: str) -> None:
    unmodded_icon_path: str = None
    for path in unmodded_icon_paths:
        if os.path.isdir(path):
            unmodded_icon_path = path
    
    modded_icon_path: str = None
    for path in modded_icon_paths:
        if os.path.isdir(path):
            modded_icon_path = path
    
    if not unmodded_icon_path:
        raise Exception('[icons.generate_imageset()]: unmodded_icon_path = None')
    if not modded_icon_path:
        raise Exception('[icons.generate_imageset()]: modded_icon_path = None')
    
    shutil.copytree(unmodded_icon_path, savepath)
    
    used_imagesets: list[str] = []
    for size, icons in modded_icons.items():
        for name in icons:
            icon_data: dict = data_modded[size][name]
            imageset: str = icon_data['set']
            icon_path: str = os.path.join(modded_icon_path, f'{imageset}.png')

            x: int = icon_data['x']
            y: int = icon_data['y']
            w: int = icon_data['w']
            h: int = icon_data['h']

            icon: Image.Image = Image.open(icon_path)
            icon = icon.crop((x,y,x+w,y+h))

            new_icon_data = data_new[size][name]
            imageset: str = new_icon_data['set']
            x: int = new_icon_data['x']
            y: int = new_icon_data['y']
            image: Image.Image = Image.open(os.path.join(savepath, f'{imageset}.png'))
            image.paste(icon, (x,y))
            image.save(os.path.join(savepath, f'{imageset}.png'))

            if imageset not in used_imagesets:
                used_imagesets.append(f'{imageset}.png')
    
    delete_unmodded_imagesets(savepath, used_imagesets)


# Prevents bloat from unmodded files
def delete_unmodded_imagesets(savepath, used_imagesets):
    imagesets: list[str] = os.listdir(savepath)
    to_be_deleted: list[str] = [file for file in imagesets if not file in used_imagesets]
    for file in to_be_deleted:
        path: str = os.path.join(savepath, file)
        os.remove(path)


# Used for debugging
def preview(image: Image.Image) -> None:
    if isinstance(image, Image.Image):
        image.show()
        time.sleep(2)
        os.system("taskkill /f /im Photos.exe >nul 2>&1")
    
    else:
        print('Unable to preview image')


def main() -> None:
    print('version.py')
    print('module used in Kliko\'s mod updater')
    input('Press ENTER to exit . . .')


if __name__ == '__main__':
    main()